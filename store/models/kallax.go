// Code generated by https://github.com/src-d/go-kallax. DO NOT EDIT.
// Please, do not touch the code below, and if you do, do it under your own
// risk. Take into account that all the code you write here will be completely
// erased from earth the next time you generate the kallax models.
package models

import (
	"database/sql"
	"fmt"
	"time"

	kallax "gopkg.in/src-d/go-kallax.v1"
	"gopkg.in/src-d/go-kallax.v1/types"
	"gopkg.in/src-d/lookout-sdk.v0/pb"
)

var _ types.SQLType
var _ fmt.Formatter

type modelSaveFunc func(*kallax.Store) error

// NewComment returns a new instance of Comment.
func NewComment(r *ReviewEvent, c *pb.Comment) (record *Comment) {
	return newComment(r, c)
}

// GetID returns the primary key of the model.
func (r *Comment) GetID() kallax.Identifier {
	return (*kallax.ULID)(&r.ID)
}

// ColumnAddress returns the pointer to the value of the given column.
func (r *Comment) ColumnAddress(col string) (interface{}, error) {
	switch col {
	case "id":
		return (*kallax.ULID)(&r.ID), nil
	case "created_at":
		return &r.Timestamps.CreatedAt, nil
	case "updated_at":
		return &r.Timestamps.UpdatedAt, nil
	case "review_event_id":
		return types.Nullable(kallax.VirtualColumn("review_event_id", r, new(kallax.ULID))), nil
	case "file":
		return &r.Comment.File, nil
	case "line":
		return &r.Comment.Line, nil
	case "text":
		return &r.Comment.Text, nil
	case "confidence":
		return &r.Comment.Confidence, nil
	case "analyzer":
		return &r.Analyzer, nil

	default:
		return nil, fmt.Errorf("kallax: invalid column in Comment: %s", col)
	}
}

// Value returns the value of the given column.
func (r *Comment) Value(col string) (interface{}, error) {
	switch col {
	case "id":
		return r.ID, nil
	case "created_at":
		return r.Timestamps.CreatedAt, nil
	case "updated_at":
		return r.Timestamps.UpdatedAt, nil
	case "review_event_id":
		v := r.Model.VirtualColumn(col)
		if v == nil {
			return nil, kallax.ErrEmptyVirtualColumn
		}
		return v, nil
	case "file":
		return r.Comment.File, nil
	case "line":
		return r.Comment.Line, nil
	case "text":
		return r.Comment.Text, nil
	case "confidence":
		return r.Comment.Confidence, nil
	case "analyzer":
		return r.Analyzer, nil

	default:
		return nil, fmt.Errorf("kallax: invalid column in Comment: %s", col)
	}
}

// NewRelationshipRecord returns a new record for the relatiobship in the given
// field.
func (r *Comment) NewRelationshipRecord(field string) (kallax.Record, error) {
	switch field {
	case "ReviewEvent":
		return new(ReviewEvent), nil

	}
	return nil, fmt.Errorf("kallax: model Comment has no relationship %s", field)
}

// SetRelationship sets the given relationship in the given field.
func (r *Comment) SetRelationship(field string, rel interface{}) error {
	switch field {
	case "ReviewEvent":
		val, ok := rel.(*ReviewEvent)
		if !ok {
			return fmt.Errorf("kallax: record of type %t can't be assigned to relationship ReviewEvent", rel)
		}
		if !val.GetID().IsEmpty() {
			r.ReviewEvent = val
		}

		return nil

	}
	return fmt.Errorf("kallax: model Comment has no relationship %s", field)
}

// CommentStore is the entity to access the records of the type Comment
// in the database.
type CommentStore struct {
	*kallax.Store
}

// NewCommentStore creates a new instance of CommentStore
// using a SQL database.
func NewCommentStore(db *sql.DB) *CommentStore {
	return &CommentStore{kallax.NewStore(db)}
}

// GenericStore returns the generic store of this store.
func (s *CommentStore) GenericStore() *kallax.Store {
	return s.Store
}

// SetGenericStore changes the generic store of this store.
func (s *CommentStore) SetGenericStore(store *kallax.Store) {
	s.Store = store
}

// Debug returns a new store that will print all SQL statements to stdout using
// the log.Printf function.
func (s *CommentStore) Debug() *CommentStore {
	return &CommentStore{s.Store.Debug()}
}

// DebugWith returns a new store that will print all SQL statements using the
// given logger function.
func (s *CommentStore) DebugWith(logger kallax.LoggerFunc) *CommentStore {
	return &CommentStore{s.Store.DebugWith(logger)}
}

// DisableCacher turns off prepared statements, which can be useful in some scenarios.
func (s *CommentStore) DisableCacher() *CommentStore {
	return &CommentStore{s.Store.DisableCacher()}
}

func (s *CommentStore) inverseRecords(record *Comment) []modelSaveFunc {
	var result []modelSaveFunc

	if record.ReviewEvent != nil && !record.ReviewEvent.IsSaving() {
		record.AddVirtualColumn("review_event_id", record.ReviewEvent.GetID())
		result = append(result, func(store *kallax.Store) error {
			_, err := (&ReviewEventStore{store}).Save(record.ReviewEvent)
			return err
		})
	}

	return result
}

// Insert inserts a Comment in the database. A non-persisted object is
// required for this operation.
func (s *CommentStore) Insert(record *Comment) error {
	record.SetSaving(true)
	defer record.SetSaving(false)

	record.CreatedAt = record.CreatedAt.Truncate(time.Microsecond)
	record.UpdatedAt = record.UpdatedAt.Truncate(time.Microsecond)

	if err := record.BeforeSave(); err != nil {
		return err
	}

	inverseRecords := s.inverseRecords(record)

	if len(inverseRecords) > 0 {
		return s.Store.Transaction(func(s *kallax.Store) error {
			for _, r := range inverseRecords {
				if err := r(s); err != nil {
					return err
				}
			}

			if err := s.Insert(Schema.Comment.BaseSchema, record); err != nil {
				return err
			}

			return nil
		})
	}

	return s.Store.Insert(Schema.Comment.BaseSchema, record)
}

// Update updates the given record on the database. If the columns are given,
// only these columns will be updated. Otherwise all of them will be.
// Be very careful with this, as you will have a potentially different object
// in memory but not on the database.
// Only writable records can be updated. Writable objects are those that have
// been just inserted or retrieved using a query with no custom select fields.
func (s *CommentStore) Update(record *Comment, cols ...kallax.SchemaField) (updated int64, err error) {
	record.CreatedAt = record.CreatedAt.Truncate(time.Microsecond)
	record.UpdatedAt = record.UpdatedAt.Truncate(time.Microsecond)

	record.SetSaving(true)
	defer record.SetSaving(false)

	if err := record.BeforeSave(); err != nil {
		return 0, err
	}

	inverseRecords := s.inverseRecords(record)

	if len(inverseRecords) > 0 {
		err = s.Store.Transaction(func(s *kallax.Store) error {
			for _, r := range inverseRecords {
				if err := r(s); err != nil {
					return err
				}
			}

			updated, err = s.Update(Schema.Comment.BaseSchema, record, cols...)
			if err != nil {
				return err
			}

			return nil
		})
		if err != nil {
			return 0, err
		}

		return updated, nil
	}

	return s.Store.Update(Schema.Comment.BaseSchema, record, cols...)
}

// Save inserts the object if the record is not persisted, otherwise it updates
// it. Same rules of Update and Insert apply depending on the case.
func (s *CommentStore) Save(record *Comment) (updated bool, err error) {
	if !record.IsPersisted() {
		return false, s.Insert(record)
	}

	rowsUpdated, err := s.Update(record)
	if err != nil {
		return false, err
	}

	return rowsUpdated > 0, nil
}

// Delete removes the given record from the database.
func (s *CommentStore) Delete(record *Comment) error {
	return s.Store.Delete(Schema.Comment.BaseSchema, record)
}

// Find returns the set of results for the given query.
func (s *CommentStore) Find(q *CommentQuery) (*CommentResultSet, error) {
	rs, err := s.Store.Find(q)
	if err != nil {
		return nil, err
	}

	return NewCommentResultSet(rs), nil
}

// MustFind returns the set of results for the given query, but panics if there
// is any error.
func (s *CommentStore) MustFind(q *CommentQuery) *CommentResultSet {
	return NewCommentResultSet(s.Store.MustFind(q))
}

// Count returns the number of rows that would be retrieved with the given
// query.
func (s *CommentStore) Count(q *CommentQuery) (int64, error) {
	return s.Store.Count(q)
}

// MustCount returns the number of rows that would be retrieved with the given
// query, but panics if there is an error.
func (s *CommentStore) MustCount(q *CommentQuery) int64 {
	return s.Store.MustCount(q)
}

// FindOne returns the first row returned by the given query.
// `ErrNotFound` is returned if there are no results.
func (s *CommentStore) FindOne(q *CommentQuery) (*Comment, error) {
	q.Limit(1)
	q.Offset(0)
	rs, err := s.Find(q)
	if err != nil {
		return nil, err
	}

	if !rs.Next() {
		return nil, kallax.ErrNotFound
	}

	record, err := rs.Get()
	if err != nil {
		return nil, err
	}

	if err := rs.Close(); err != nil {
		return nil, err
	}

	return record, nil
}

// FindAll returns a list of all the rows returned by the given query.
func (s *CommentStore) FindAll(q *CommentQuery) ([]*Comment, error) {
	rs, err := s.Find(q)
	if err != nil {
		return nil, err
	}

	return rs.All()
}

// MustFindOne returns the first row retrieved by the given query. It panics
// if there is an error or if there are no rows.
func (s *CommentStore) MustFindOne(q *CommentQuery) *Comment {
	record, err := s.FindOne(q)
	if err != nil {
		panic(err)
	}
	return record
}

// Reload refreshes the Comment with the data in the database and
// makes it writable.
func (s *CommentStore) Reload(record *Comment) error {
	return s.Store.Reload(Schema.Comment.BaseSchema, record)
}

// Transaction executes the given callback in a transaction and rollbacks if
// an error is returned.
// The transaction is only open in the store passed as a parameter to the
// callback.
func (s *CommentStore) Transaction(callback func(*CommentStore) error) error {
	if callback == nil {
		return kallax.ErrInvalidTxCallback
	}

	return s.Store.Transaction(func(store *kallax.Store) error {
		return callback(&CommentStore{store})
	})
}

// CommentQuery is the object used to create queries for the Comment
// entity.
type CommentQuery struct {
	*kallax.BaseQuery
}

// NewCommentQuery returns a new instance of CommentQuery.
func NewCommentQuery() *CommentQuery {
	return &CommentQuery{
		BaseQuery: kallax.NewBaseQuery(Schema.Comment.BaseSchema),
	}
}

// Select adds columns to select in the query.
func (q *CommentQuery) Select(columns ...kallax.SchemaField) *CommentQuery {
	if len(columns) == 0 {
		return q
	}
	q.BaseQuery.Select(columns...)
	return q
}

// SelectNot excludes columns from being selected in the query.
func (q *CommentQuery) SelectNot(columns ...kallax.SchemaField) *CommentQuery {
	q.BaseQuery.SelectNot(columns...)
	return q
}

// Copy returns a new identical copy of the query. Remember queries are mutable
// so make a copy any time you need to reuse them.
func (q *CommentQuery) Copy() *CommentQuery {
	return &CommentQuery{
		BaseQuery: q.BaseQuery.Copy(),
	}
}

// Order adds order clauses to the query for the given columns.
func (q *CommentQuery) Order(cols ...kallax.ColumnOrder) *CommentQuery {
	q.BaseQuery.Order(cols...)
	return q
}

// BatchSize sets the number of items to fetch per batch when there are 1:N
// relationships selected in the query.
func (q *CommentQuery) BatchSize(size uint64) *CommentQuery {
	q.BaseQuery.BatchSize(size)
	return q
}

// Limit sets the max number of items to retrieve.
func (q *CommentQuery) Limit(n uint64) *CommentQuery {
	q.BaseQuery.Limit(n)
	return q
}

// Offset sets the number of items to skip from the result set of items.
func (q *CommentQuery) Offset(n uint64) *CommentQuery {
	q.BaseQuery.Offset(n)
	return q
}

// Where adds a condition to the query. All conditions added are concatenated
// using a logical AND.
func (q *CommentQuery) Where(cond kallax.Condition) *CommentQuery {
	q.BaseQuery.Where(cond)
	return q
}

func (q *CommentQuery) WithReviewEvent() *CommentQuery {
	q.AddRelation(Schema.ReviewEvent.BaseSchema, "ReviewEvent", kallax.OneToOne, nil)
	return q
}

// FindByID adds a new filter to the query that will require that
// the ID property is equal to one of the passed values; if no passed values,
// it will do nothing.
func (q *CommentQuery) FindByID(v ...kallax.ULID) *CommentQuery {
	if len(v) == 0 {
		return q
	}
	values := make([]interface{}, len(v))
	for i, val := range v {
		values[i] = val
	}
	return q.Where(kallax.In(Schema.Comment.ID, values...))
}

// FindByCreatedAt adds a new filter to the query that will require that
// the CreatedAt property is equal to the passed value.
func (q *CommentQuery) FindByCreatedAt(cond kallax.ScalarCond, v time.Time) *CommentQuery {
	return q.Where(cond(Schema.Comment.CreatedAt, v))
}

// FindByUpdatedAt adds a new filter to the query that will require that
// the UpdatedAt property is equal to the passed value.
func (q *CommentQuery) FindByUpdatedAt(cond kallax.ScalarCond, v time.Time) *CommentQuery {
	return q.Where(cond(Schema.Comment.UpdatedAt, v))
}

// FindByReviewEvent adds a new filter to the query that will require that
// the foreign key of ReviewEvent is equal to the passed value.
func (q *CommentQuery) FindByReviewEvent(v kallax.ULID) *CommentQuery {
	return q.Where(kallax.Eq(Schema.Comment.ReviewEventFK, v))
}

// FindByFile adds a new filter to the query that will require that
// the File property is equal to the passed value.
func (q *CommentQuery) FindByFile(v string) *CommentQuery {
	return q.Where(kallax.Eq(Schema.Comment.File, v))
}

// FindByLine adds a new filter to the query that will require that
// the Line property is equal to the passed value.
func (q *CommentQuery) FindByLine(cond kallax.ScalarCond, v int32) *CommentQuery {
	return q.Where(cond(Schema.Comment.Line, v))
}

// FindByText adds a new filter to the query that will require that
// the Text property is equal to the passed value.
func (q *CommentQuery) FindByText(v string) *CommentQuery {
	return q.Where(kallax.Eq(Schema.Comment.Text, v))
}

// FindByConfidence adds a new filter to the query that will require that
// the Confidence property is equal to the passed value.
func (q *CommentQuery) FindByConfidence(cond kallax.ScalarCond, v uint32) *CommentQuery {
	return q.Where(cond(Schema.Comment.Confidence, v))
}

// FindByAnalyzer adds a new filter to the query that will require that
// the Analyzer property is equal to the passed value.
func (q *CommentQuery) FindByAnalyzer(v string) *CommentQuery {
	return q.Where(kallax.Eq(Schema.Comment.Analyzer, v))
}

// CommentResultSet is the set of results returned by a query to the
// database.
type CommentResultSet struct {
	ResultSet kallax.ResultSet
	last      *Comment
	lastErr   error
}

// NewCommentResultSet creates a new result set for rows of the type
// Comment.
func NewCommentResultSet(rs kallax.ResultSet) *CommentResultSet {
	return &CommentResultSet{ResultSet: rs}
}

// Next fetches the next item in the result set and returns true if there is
// a next item.
// The result set is closed automatically when there are no more items.
func (rs *CommentResultSet) Next() bool {
	if !rs.ResultSet.Next() {
		rs.lastErr = rs.ResultSet.Close()
		rs.last = nil
		return false
	}

	var record kallax.Record
	record, rs.lastErr = rs.ResultSet.Get(Schema.Comment.BaseSchema)
	if rs.lastErr != nil {
		rs.last = nil
	} else {
		var ok bool
		rs.last, ok = record.(*Comment)
		if !ok {
			rs.lastErr = fmt.Errorf("kallax: unable to convert record to *Comment")
			rs.last = nil
		}
	}

	return true
}

// Get retrieves the last fetched item from the result set and the last error.
func (rs *CommentResultSet) Get() (*Comment, error) {
	return rs.last, rs.lastErr
}

// ForEach iterates over the complete result set passing every record found to
// the given callback. It is possible to stop the iteration by returning
// `kallax.ErrStop` in the callback.
// Result set is always closed at the end.
func (rs *CommentResultSet) ForEach(fn func(*Comment) error) error {
	for rs.Next() {
		record, err := rs.Get()
		if err != nil {
			return err
		}

		if err := fn(record); err != nil {
			if err == kallax.ErrStop {
				return rs.Close()
			}

			return err
		}
	}
	return nil
}

// All returns all records on the result set and closes the result set.
func (rs *CommentResultSet) All() ([]*Comment, error) {
	var result []*Comment
	for rs.Next() {
		record, err := rs.Get()
		if err != nil {
			return nil, err
		}
		result = append(result, record)
	}
	return result, nil
}

// One returns the first record on the result set and closes the result set.
func (rs *CommentResultSet) One() (*Comment, error) {
	if !rs.Next() {
		return nil, kallax.ErrNotFound
	}

	record, err := rs.Get()
	if err != nil {
		return nil, err
	}

	if err := rs.Close(); err != nil {
		return nil, err
	}

	return record, nil
}

// Err returns the last error occurred.
func (rs *CommentResultSet) Err() error {
	return rs.lastErr
}

// Close closes the result set.
func (rs *CommentResultSet) Close() error {
	return rs.ResultSet.Close()
}

// NewOrganization returns a new instance of Organization.
func NewOrganization(provider string, internalID string, config string) (record *Organization) {
	return newOrganization(provider, internalID, config)
}

// GetID returns the primary key of the model.
func (r *Organization) GetID() kallax.Identifier {
	return (*kallax.ULID)(&r.ID)
}

// ColumnAddress returns the pointer to the value of the given column.
func (r *Organization) ColumnAddress(col string) (interface{}, error) {
	switch col {
	case "id":
		return (*kallax.ULID)(&r.ID), nil
	case "provider":
		return &r.Provider, nil
	case "internal_id":
		return &r.InternalID, nil
	case "config":
		return &r.Config, nil

	default:
		return nil, fmt.Errorf("kallax: invalid column in Organization: %s", col)
	}
}

// Value returns the value of the given column.
func (r *Organization) Value(col string) (interface{}, error) {
	switch col {
	case "id":
		return r.ID, nil
	case "provider":
		return r.Provider, nil
	case "internal_id":
		return r.InternalID, nil
	case "config":
		return r.Config, nil

	default:
		return nil, fmt.Errorf("kallax: invalid column in Organization: %s", col)
	}
}

// NewRelationshipRecord returns a new record for the relatiobship in the given
// field.
func (r *Organization) NewRelationshipRecord(field string) (kallax.Record, error) {
	return nil, fmt.Errorf("kallax: model Organization has no relationships")
}

// SetRelationship sets the given relationship in the given field.
func (r *Organization) SetRelationship(field string, rel interface{}) error {
	return fmt.Errorf("kallax: model Organization has no relationships")
}

// OrganizationStore is the entity to access the records of the type Organization
// in the database.
type OrganizationStore struct {
	*kallax.Store
}

// NewOrganizationStore creates a new instance of OrganizationStore
// using a SQL database.
func NewOrganizationStore(db *sql.DB) *OrganizationStore {
	return &OrganizationStore{kallax.NewStore(db)}
}

// GenericStore returns the generic store of this store.
func (s *OrganizationStore) GenericStore() *kallax.Store {
	return s.Store
}

// SetGenericStore changes the generic store of this store.
func (s *OrganizationStore) SetGenericStore(store *kallax.Store) {
	s.Store = store
}

// Debug returns a new store that will print all SQL statements to stdout using
// the log.Printf function.
func (s *OrganizationStore) Debug() *OrganizationStore {
	return &OrganizationStore{s.Store.Debug()}
}

// DebugWith returns a new store that will print all SQL statements using the
// given logger function.
func (s *OrganizationStore) DebugWith(logger kallax.LoggerFunc) *OrganizationStore {
	return &OrganizationStore{s.Store.DebugWith(logger)}
}

// DisableCacher turns off prepared statements, which can be useful in some scenarios.
func (s *OrganizationStore) DisableCacher() *OrganizationStore {
	return &OrganizationStore{s.Store.DisableCacher()}
}

// Insert inserts a Organization in the database. A non-persisted object is
// required for this operation.
func (s *OrganizationStore) Insert(record *Organization) error {
	record.SetSaving(true)
	defer record.SetSaving(false)

	return s.Store.Insert(Schema.Organization.BaseSchema, record)
}

// Update updates the given record on the database. If the columns are given,
// only these columns will be updated. Otherwise all of them will be.
// Be very careful with this, as you will have a potentially different object
// in memory but not on the database.
// Only writable records can be updated. Writable objects are those that have
// been just inserted or retrieved using a query with no custom select fields.
func (s *OrganizationStore) Update(record *Organization, cols ...kallax.SchemaField) (updated int64, err error) {
	record.SetSaving(true)
	defer record.SetSaving(false)

	return s.Store.Update(Schema.Organization.BaseSchema, record, cols...)
}

// Save inserts the object if the record is not persisted, otherwise it updates
// it. Same rules of Update and Insert apply depending on the case.
func (s *OrganizationStore) Save(record *Organization) (updated bool, err error) {
	if !record.IsPersisted() {
		return false, s.Insert(record)
	}

	rowsUpdated, err := s.Update(record)
	if err != nil {
		return false, err
	}

	return rowsUpdated > 0, nil
}

// Delete removes the given record from the database.
func (s *OrganizationStore) Delete(record *Organization) error {
	return s.Store.Delete(Schema.Organization.BaseSchema, record)
}

// Find returns the set of results for the given query.
func (s *OrganizationStore) Find(q *OrganizationQuery) (*OrganizationResultSet, error) {
	rs, err := s.Store.Find(q)
	if err != nil {
		return nil, err
	}

	return NewOrganizationResultSet(rs), nil
}

// MustFind returns the set of results for the given query, but panics if there
// is any error.
func (s *OrganizationStore) MustFind(q *OrganizationQuery) *OrganizationResultSet {
	return NewOrganizationResultSet(s.Store.MustFind(q))
}

// Count returns the number of rows that would be retrieved with the given
// query.
func (s *OrganizationStore) Count(q *OrganizationQuery) (int64, error) {
	return s.Store.Count(q)
}

// MustCount returns the number of rows that would be retrieved with the given
// query, but panics if there is an error.
func (s *OrganizationStore) MustCount(q *OrganizationQuery) int64 {
	return s.Store.MustCount(q)
}

// FindOne returns the first row returned by the given query.
// `ErrNotFound` is returned if there are no results.
func (s *OrganizationStore) FindOne(q *OrganizationQuery) (*Organization, error) {
	q.Limit(1)
	q.Offset(0)
	rs, err := s.Find(q)
	if err != nil {
		return nil, err
	}

	if !rs.Next() {
		return nil, kallax.ErrNotFound
	}

	record, err := rs.Get()
	if err != nil {
		return nil, err
	}

	if err := rs.Close(); err != nil {
		return nil, err
	}

	return record, nil
}

// FindAll returns a list of all the rows returned by the given query.
func (s *OrganizationStore) FindAll(q *OrganizationQuery) ([]*Organization, error) {
	rs, err := s.Find(q)
	if err != nil {
		return nil, err
	}

	return rs.All()
}

// MustFindOne returns the first row retrieved by the given query. It panics
// if there is an error or if there are no rows.
func (s *OrganizationStore) MustFindOne(q *OrganizationQuery) *Organization {
	record, err := s.FindOne(q)
	if err != nil {
		panic(err)
	}
	return record
}

// Reload refreshes the Organization with the data in the database and
// makes it writable.
func (s *OrganizationStore) Reload(record *Organization) error {
	return s.Store.Reload(Schema.Organization.BaseSchema, record)
}

// Transaction executes the given callback in a transaction and rollbacks if
// an error is returned.
// The transaction is only open in the store passed as a parameter to the
// callback.
func (s *OrganizationStore) Transaction(callback func(*OrganizationStore) error) error {
	if callback == nil {
		return kallax.ErrInvalidTxCallback
	}

	return s.Store.Transaction(func(store *kallax.Store) error {
		return callback(&OrganizationStore{store})
	})
}

// OrganizationQuery is the object used to create queries for the Organization
// entity.
type OrganizationQuery struct {
	*kallax.BaseQuery
}

// NewOrganizationQuery returns a new instance of OrganizationQuery.
func NewOrganizationQuery() *OrganizationQuery {
	return &OrganizationQuery{
		BaseQuery: kallax.NewBaseQuery(Schema.Organization.BaseSchema),
	}
}

// Select adds columns to select in the query.
func (q *OrganizationQuery) Select(columns ...kallax.SchemaField) *OrganizationQuery {
	if len(columns) == 0 {
		return q
	}
	q.BaseQuery.Select(columns...)
	return q
}

// SelectNot excludes columns from being selected in the query.
func (q *OrganizationQuery) SelectNot(columns ...kallax.SchemaField) *OrganizationQuery {
	q.BaseQuery.SelectNot(columns...)
	return q
}

// Copy returns a new identical copy of the query. Remember queries are mutable
// so make a copy any time you need to reuse them.
func (q *OrganizationQuery) Copy() *OrganizationQuery {
	return &OrganizationQuery{
		BaseQuery: q.BaseQuery.Copy(),
	}
}

// Order adds order clauses to the query for the given columns.
func (q *OrganizationQuery) Order(cols ...kallax.ColumnOrder) *OrganizationQuery {
	q.BaseQuery.Order(cols...)
	return q
}

// BatchSize sets the number of items to fetch per batch when there are 1:N
// relationships selected in the query.
func (q *OrganizationQuery) BatchSize(size uint64) *OrganizationQuery {
	q.BaseQuery.BatchSize(size)
	return q
}

// Limit sets the max number of items to retrieve.
func (q *OrganizationQuery) Limit(n uint64) *OrganizationQuery {
	q.BaseQuery.Limit(n)
	return q
}

// Offset sets the number of items to skip from the result set of items.
func (q *OrganizationQuery) Offset(n uint64) *OrganizationQuery {
	q.BaseQuery.Offset(n)
	return q
}

// Where adds a condition to the query. All conditions added are concatenated
// using a logical AND.
func (q *OrganizationQuery) Where(cond kallax.Condition) *OrganizationQuery {
	q.BaseQuery.Where(cond)
	return q
}

// FindByID adds a new filter to the query that will require that
// the ID property is equal to one of the passed values; if no passed values,
// it will do nothing.
func (q *OrganizationQuery) FindByID(v ...kallax.ULID) *OrganizationQuery {
	if len(v) == 0 {
		return q
	}
	values := make([]interface{}, len(v))
	for i, val := range v {
		values[i] = val
	}
	return q.Where(kallax.In(Schema.Organization.ID, values...))
}

// FindByProvider adds a new filter to the query that will require that
// the Provider property is equal to the passed value.
func (q *OrganizationQuery) FindByProvider(v string) *OrganizationQuery {
	return q.Where(kallax.Eq(Schema.Organization.Provider, v))
}

// FindByInternalID adds a new filter to the query that will require that
// the InternalID property is equal to the passed value.
func (q *OrganizationQuery) FindByInternalID(v string) *OrganizationQuery {
	return q.Where(kallax.Eq(Schema.Organization.InternalID, v))
}

// FindByConfig adds a new filter to the query that will require that
// the Config property is equal to the passed value.
func (q *OrganizationQuery) FindByConfig(v string) *OrganizationQuery {
	return q.Where(kallax.Eq(Schema.Organization.Config, v))
}

// OrganizationResultSet is the set of results returned by a query to the
// database.
type OrganizationResultSet struct {
	ResultSet kallax.ResultSet
	last      *Organization
	lastErr   error
}

// NewOrganizationResultSet creates a new result set for rows of the type
// Organization.
func NewOrganizationResultSet(rs kallax.ResultSet) *OrganizationResultSet {
	return &OrganizationResultSet{ResultSet: rs}
}

// Next fetches the next item in the result set and returns true if there is
// a next item.
// The result set is closed automatically when there are no more items.
func (rs *OrganizationResultSet) Next() bool {
	if !rs.ResultSet.Next() {
		rs.lastErr = rs.ResultSet.Close()
		rs.last = nil
		return false
	}

	var record kallax.Record
	record, rs.lastErr = rs.ResultSet.Get(Schema.Organization.BaseSchema)
	if rs.lastErr != nil {
		rs.last = nil
	} else {
		var ok bool
		rs.last, ok = record.(*Organization)
		if !ok {
			rs.lastErr = fmt.Errorf("kallax: unable to convert record to *Organization")
			rs.last = nil
		}
	}

	return true
}

// Get retrieves the last fetched item from the result set and the last error.
func (rs *OrganizationResultSet) Get() (*Organization, error) {
	return rs.last, rs.lastErr
}

// ForEach iterates over the complete result set passing every record found to
// the given callback. It is possible to stop the iteration by returning
// `kallax.ErrStop` in the callback.
// Result set is always closed at the end.
func (rs *OrganizationResultSet) ForEach(fn func(*Organization) error) error {
	for rs.Next() {
		record, err := rs.Get()
		if err != nil {
			return err
		}

		if err := fn(record); err != nil {
			if err == kallax.ErrStop {
				return rs.Close()
			}

			return err
		}
	}
	return nil
}

// All returns all records on the result set and closes the result set.
func (rs *OrganizationResultSet) All() ([]*Organization, error) {
	var result []*Organization
	for rs.Next() {
		record, err := rs.Get()
		if err != nil {
			return nil, err
		}
		result = append(result, record)
	}
	return result, nil
}

// One returns the first record on the result set and closes the result set.
func (rs *OrganizationResultSet) One() (*Organization, error) {
	if !rs.Next() {
		return nil, kallax.ErrNotFound
	}

	record, err := rs.Get()
	if err != nil {
		return nil, err
	}

	if err := rs.Close(); err != nil {
		return nil, err
	}

	return record, nil
}

// Err returns the last error occurred.
func (rs *OrganizationResultSet) Err() error {
	return rs.lastErr
}

// Close closes the result set.
func (rs *OrganizationResultSet) Close() error {
	return rs.ResultSet.Close()
}

// NewPushEvent returns a new instance of PushEvent.
func NewPushEvent(e *pb.PushEvent) (record *PushEvent) {
	return newPushEvent(e)
}

// GetID returns the primary key of the model.
func (r *PushEvent) GetID() kallax.Identifier {
	return (*kallax.ULID)(&r.ID)
}

// ColumnAddress returns the pointer to the value of the given column.
func (r *PushEvent) ColumnAddress(col string) (interface{}, error) {
	switch col {
	case "id":
		return (*kallax.ULID)(&r.ID), nil
	case "status":
		return (*string)(&r.Status), nil
	case "provider":
		return &r.PushEvent.Provider, nil
	case "internal_id":
		return &r.PushEvent.InternalID, nil
	case "created_at":
		return &r.PushEvent.CreatedAt, nil
	case "commits":
		return &r.PushEvent.Commits, nil
	case "distinct_commits":
		return &r.PushEvent.DistinctCommits, nil
	case "configuration":
		return types.JSON(&r.PushEvent.Configuration), nil
	case "base":
		return types.JSON(&r.PushEvent.CommitRevision.Base), nil
	case "head":
		return types.JSON(&r.PushEvent.CommitRevision.Head), nil

	default:
		return nil, fmt.Errorf("kallax: invalid column in PushEvent: %s", col)
	}
}

// Value returns the value of the given column.
func (r *PushEvent) Value(col string) (interface{}, error) {
	switch col {
	case "id":
		return r.ID, nil
	case "status":
		return (string)(r.Status), nil
	case "provider":
		return r.PushEvent.Provider, nil
	case "internal_id":
		return r.PushEvent.InternalID, nil
	case "created_at":
		return r.PushEvent.CreatedAt, nil
	case "commits":
		return r.PushEvent.Commits, nil
	case "distinct_commits":
		return r.PushEvent.DistinctCommits, nil
	case "configuration":
		return types.JSON(r.PushEvent.Configuration), nil
	case "base":
		return types.JSON(r.PushEvent.CommitRevision.Base), nil
	case "head":
		return types.JSON(r.PushEvent.CommitRevision.Head), nil

	default:
		return nil, fmt.Errorf("kallax: invalid column in PushEvent: %s", col)
	}
}

// NewRelationshipRecord returns a new record for the relatiobship in the given
// field.
func (r *PushEvent) NewRelationshipRecord(field string) (kallax.Record, error) {
	return nil, fmt.Errorf("kallax: model PushEvent has no relationships")
}

// SetRelationship sets the given relationship in the given field.
func (r *PushEvent) SetRelationship(field string, rel interface{}) error {
	return fmt.Errorf("kallax: model PushEvent has no relationships")
}

// PushEventStore is the entity to access the records of the type PushEvent
// in the database.
type PushEventStore struct {
	*kallax.Store
}

// NewPushEventStore creates a new instance of PushEventStore
// using a SQL database.
func NewPushEventStore(db *sql.DB) *PushEventStore {
	return &PushEventStore{kallax.NewStore(db)}
}

// GenericStore returns the generic store of this store.
func (s *PushEventStore) GenericStore() *kallax.Store {
	return s.Store
}

// SetGenericStore changes the generic store of this store.
func (s *PushEventStore) SetGenericStore(store *kallax.Store) {
	s.Store = store
}

// Debug returns a new store that will print all SQL statements to stdout using
// the log.Printf function.
func (s *PushEventStore) Debug() *PushEventStore {
	return &PushEventStore{s.Store.Debug()}
}

// DebugWith returns a new store that will print all SQL statements using the
// given logger function.
func (s *PushEventStore) DebugWith(logger kallax.LoggerFunc) *PushEventStore {
	return &PushEventStore{s.Store.DebugWith(logger)}
}

// DisableCacher turns off prepared statements, which can be useful in some scenarios.
func (s *PushEventStore) DisableCacher() *PushEventStore {
	return &PushEventStore{s.Store.DisableCacher()}
}

// Insert inserts a PushEvent in the database. A non-persisted object is
// required for this operation.
func (s *PushEventStore) Insert(record *PushEvent) error {
	record.SetSaving(true)
	defer record.SetSaving(false)

	record.CreatedAt = record.CreatedAt.Truncate(time.Microsecond)

	return s.Store.Insert(Schema.PushEvent.BaseSchema, record)
}

// Update updates the given record on the database. If the columns are given,
// only these columns will be updated. Otherwise all of them will be.
// Be very careful with this, as you will have a potentially different object
// in memory but not on the database.
// Only writable records can be updated. Writable objects are those that have
// been just inserted or retrieved using a query with no custom select fields.
func (s *PushEventStore) Update(record *PushEvent, cols ...kallax.SchemaField) (updated int64, err error) {
	record.CreatedAt = record.CreatedAt.Truncate(time.Microsecond)

	record.SetSaving(true)
	defer record.SetSaving(false)

	return s.Store.Update(Schema.PushEvent.BaseSchema, record, cols...)
}

// Save inserts the object if the record is not persisted, otherwise it updates
// it. Same rules of Update and Insert apply depending on the case.
func (s *PushEventStore) Save(record *PushEvent) (updated bool, err error) {
	if !record.IsPersisted() {
		return false, s.Insert(record)
	}

	rowsUpdated, err := s.Update(record)
	if err != nil {
		return false, err
	}

	return rowsUpdated > 0, nil
}

// Delete removes the given record from the database.
func (s *PushEventStore) Delete(record *PushEvent) error {
	return s.Store.Delete(Schema.PushEvent.BaseSchema, record)
}

// Find returns the set of results for the given query.
func (s *PushEventStore) Find(q *PushEventQuery) (*PushEventResultSet, error) {
	rs, err := s.Store.Find(q)
	if err != nil {
		return nil, err
	}

	return NewPushEventResultSet(rs), nil
}

// MustFind returns the set of results for the given query, but panics if there
// is any error.
func (s *PushEventStore) MustFind(q *PushEventQuery) *PushEventResultSet {
	return NewPushEventResultSet(s.Store.MustFind(q))
}

// Count returns the number of rows that would be retrieved with the given
// query.
func (s *PushEventStore) Count(q *PushEventQuery) (int64, error) {
	return s.Store.Count(q)
}

// MustCount returns the number of rows that would be retrieved with the given
// query, but panics if there is an error.
func (s *PushEventStore) MustCount(q *PushEventQuery) int64 {
	return s.Store.MustCount(q)
}

// FindOne returns the first row returned by the given query.
// `ErrNotFound` is returned if there are no results.
func (s *PushEventStore) FindOne(q *PushEventQuery) (*PushEvent, error) {
	q.Limit(1)
	q.Offset(0)
	rs, err := s.Find(q)
	if err != nil {
		return nil, err
	}

	if !rs.Next() {
		return nil, kallax.ErrNotFound
	}

	record, err := rs.Get()
	if err != nil {
		return nil, err
	}

	if err := rs.Close(); err != nil {
		return nil, err
	}

	return record, nil
}

// FindAll returns a list of all the rows returned by the given query.
func (s *PushEventStore) FindAll(q *PushEventQuery) ([]*PushEvent, error) {
	rs, err := s.Find(q)
	if err != nil {
		return nil, err
	}

	return rs.All()
}

// MustFindOne returns the first row retrieved by the given query. It panics
// if there is an error or if there are no rows.
func (s *PushEventStore) MustFindOne(q *PushEventQuery) *PushEvent {
	record, err := s.FindOne(q)
	if err != nil {
		panic(err)
	}
	return record
}

// Reload refreshes the PushEvent with the data in the database and
// makes it writable.
func (s *PushEventStore) Reload(record *PushEvent) error {
	return s.Store.Reload(Schema.PushEvent.BaseSchema, record)
}

// Transaction executes the given callback in a transaction and rollbacks if
// an error is returned.
// The transaction is only open in the store passed as a parameter to the
// callback.
func (s *PushEventStore) Transaction(callback func(*PushEventStore) error) error {
	if callback == nil {
		return kallax.ErrInvalidTxCallback
	}

	return s.Store.Transaction(func(store *kallax.Store) error {
		return callback(&PushEventStore{store})
	})
}

// PushEventQuery is the object used to create queries for the PushEvent
// entity.
type PushEventQuery struct {
	*kallax.BaseQuery
}

// NewPushEventQuery returns a new instance of PushEventQuery.
func NewPushEventQuery() *PushEventQuery {
	return &PushEventQuery{
		BaseQuery: kallax.NewBaseQuery(Schema.PushEvent.BaseSchema),
	}
}

// Select adds columns to select in the query.
func (q *PushEventQuery) Select(columns ...kallax.SchemaField) *PushEventQuery {
	if len(columns) == 0 {
		return q
	}
	q.BaseQuery.Select(columns...)
	return q
}

// SelectNot excludes columns from being selected in the query.
func (q *PushEventQuery) SelectNot(columns ...kallax.SchemaField) *PushEventQuery {
	q.BaseQuery.SelectNot(columns...)
	return q
}

// Copy returns a new identical copy of the query. Remember queries are mutable
// so make a copy any time you need to reuse them.
func (q *PushEventQuery) Copy() *PushEventQuery {
	return &PushEventQuery{
		BaseQuery: q.BaseQuery.Copy(),
	}
}

// Order adds order clauses to the query for the given columns.
func (q *PushEventQuery) Order(cols ...kallax.ColumnOrder) *PushEventQuery {
	q.BaseQuery.Order(cols...)
	return q
}

// BatchSize sets the number of items to fetch per batch when there are 1:N
// relationships selected in the query.
func (q *PushEventQuery) BatchSize(size uint64) *PushEventQuery {
	q.BaseQuery.BatchSize(size)
	return q
}

// Limit sets the max number of items to retrieve.
func (q *PushEventQuery) Limit(n uint64) *PushEventQuery {
	q.BaseQuery.Limit(n)
	return q
}

// Offset sets the number of items to skip from the result set of items.
func (q *PushEventQuery) Offset(n uint64) *PushEventQuery {
	q.BaseQuery.Offset(n)
	return q
}

// Where adds a condition to the query. All conditions added are concatenated
// using a logical AND.
func (q *PushEventQuery) Where(cond kallax.Condition) *PushEventQuery {
	q.BaseQuery.Where(cond)
	return q
}

// FindByID adds a new filter to the query that will require that
// the ID property is equal to one of the passed values; if no passed values,
// it will do nothing.
func (q *PushEventQuery) FindByID(v ...kallax.ULID) *PushEventQuery {
	if len(v) == 0 {
		return q
	}
	values := make([]interface{}, len(v))
	for i, val := range v {
		values[i] = val
	}
	return q.Where(kallax.In(Schema.PushEvent.ID, values...))
}

// FindByStatus adds a new filter to the query that will require that
// the Status property is equal to the passed value.
func (q *PushEventQuery) FindByStatus(v EventStatus) *PushEventQuery {
	return q.Where(kallax.Eq(Schema.PushEvent.Status, v))
}

// FindByProvider adds a new filter to the query that will require that
// the Provider property is equal to the passed value.
func (q *PushEventQuery) FindByProvider(v string) *PushEventQuery {
	return q.Where(kallax.Eq(Schema.PushEvent.Provider, v))
}

// FindByInternalID adds a new filter to the query that will require that
// the InternalID property is equal to the passed value.
func (q *PushEventQuery) FindByInternalID(v string) *PushEventQuery {
	return q.Where(kallax.Eq(Schema.PushEvent.InternalID, v))
}

// FindByCreatedAt adds a new filter to the query that will require that
// the CreatedAt property is equal to the passed value.
func (q *PushEventQuery) FindByCreatedAt(cond kallax.ScalarCond, v time.Time) *PushEventQuery {
	return q.Where(cond(Schema.PushEvent.CreatedAt, v))
}

// FindByCommits adds a new filter to the query that will require that
// the Commits property is equal to the passed value.
func (q *PushEventQuery) FindByCommits(cond kallax.ScalarCond, v uint32) *PushEventQuery {
	return q.Where(cond(Schema.PushEvent.Commits, v))
}

// FindByDistinctCommits adds a new filter to the query that will require that
// the DistinctCommits property is equal to the passed value.
func (q *PushEventQuery) FindByDistinctCommits(cond kallax.ScalarCond, v uint32) *PushEventQuery {
	return q.Where(cond(Schema.PushEvent.DistinctCommits, v))
}

// PushEventResultSet is the set of results returned by a query to the
// database.
type PushEventResultSet struct {
	ResultSet kallax.ResultSet
	last      *PushEvent
	lastErr   error
}

// NewPushEventResultSet creates a new result set for rows of the type
// PushEvent.
func NewPushEventResultSet(rs kallax.ResultSet) *PushEventResultSet {
	return &PushEventResultSet{ResultSet: rs}
}

// Next fetches the next item in the result set and returns true if there is
// a next item.
// The result set is closed automatically when there are no more items.
func (rs *PushEventResultSet) Next() bool {
	if !rs.ResultSet.Next() {
		rs.lastErr = rs.ResultSet.Close()
		rs.last = nil
		return false
	}

	var record kallax.Record
	record, rs.lastErr = rs.ResultSet.Get(Schema.PushEvent.BaseSchema)
	if rs.lastErr != nil {
		rs.last = nil
	} else {
		var ok bool
		rs.last, ok = record.(*PushEvent)
		if !ok {
			rs.lastErr = fmt.Errorf("kallax: unable to convert record to *PushEvent")
			rs.last = nil
		}
	}

	return true
}

// Get retrieves the last fetched item from the result set and the last error.
func (rs *PushEventResultSet) Get() (*PushEvent, error) {
	return rs.last, rs.lastErr
}

// ForEach iterates over the complete result set passing every record found to
// the given callback. It is possible to stop the iteration by returning
// `kallax.ErrStop` in the callback.
// Result set is always closed at the end.
func (rs *PushEventResultSet) ForEach(fn func(*PushEvent) error) error {
	for rs.Next() {
		record, err := rs.Get()
		if err != nil {
			return err
		}

		if err := fn(record); err != nil {
			if err == kallax.ErrStop {
				return rs.Close()
			}

			return err
		}
	}
	return nil
}

// All returns all records on the result set and closes the result set.
func (rs *PushEventResultSet) All() ([]*PushEvent, error) {
	var result []*PushEvent
	for rs.Next() {
		record, err := rs.Get()
		if err != nil {
			return nil, err
		}
		result = append(result, record)
	}
	return result, nil
}

// One returns the first record on the result set and closes the result set.
func (rs *PushEventResultSet) One() (*PushEvent, error) {
	if !rs.Next() {
		return nil, kallax.ErrNotFound
	}

	record, err := rs.Get()
	if err != nil {
		return nil, err
	}

	if err := rs.Close(); err != nil {
		return nil, err
	}

	return record, nil
}

// Err returns the last error occurred.
func (rs *PushEventResultSet) Err() error {
	return rs.lastErr
}

// Close closes the result set.
func (rs *PushEventResultSet) Close() error {
	return rs.ResultSet.Close()
}

// NewReviewEvent returns a new instance of ReviewEvent.
func NewReviewEvent(e *pb.ReviewEvent) (record *ReviewEvent) {
	return newReviewEvent(e)
}

// GetID returns the primary key of the model.
func (r *ReviewEvent) GetID() kallax.Identifier {
	return (*kallax.ULID)(&r.ID)
}

// ColumnAddress returns the pointer to the value of the given column.
func (r *ReviewEvent) ColumnAddress(col string) (interface{}, error) {
	switch col {
	case "id":
		return (*kallax.ULID)(&r.ID), nil
	case "status":
		return (*string)(&r.Status), nil
	case "internal_id":
		return &r.InternalID, nil
	case "is_mergeable":
		return &r.IsMergeable, nil
	case "source":
		return types.JSON(&r.Source), nil
	case "merge":
		return types.JSON(&r.Merge), nil
	case "configuration":
		return types.JSON(&r.Configuration), nil
	case "base":
		return types.JSON(&r.Base), nil
	case "head":
		return types.JSON(&r.Head), nil
	case "created_at":
		return &r.CreatedAt, nil
	case "updated_at":
		return &r.UpdatedAt, nil
	case "review_target_id":
		return types.Nullable(kallax.VirtualColumn("review_target_id", r, new(kallax.ULID))), nil

	default:
		return nil, fmt.Errorf("kallax: invalid column in ReviewEvent: %s", col)
	}
}

// Value returns the value of the given column.
func (r *ReviewEvent) Value(col string) (interface{}, error) {
	switch col {
	case "id":
		return r.ID, nil
	case "status":
		return (string)(r.Status), nil
	case "internal_id":
		return r.InternalID, nil
	case "is_mergeable":
		return r.IsMergeable, nil
	case "source":
		return types.JSON(r.Source), nil
	case "merge":
		return types.JSON(r.Merge), nil
	case "configuration":
		return types.JSON(r.Configuration), nil
	case "base":
		return types.JSON(r.Base), nil
	case "head":
		return types.JSON(r.Head), nil
	case "created_at":
		return r.CreatedAt, nil
	case "updated_at":
		return r.UpdatedAt, nil
	case "review_target_id":
		v := r.Model.VirtualColumn(col)
		if v == nil {
			return nil, kallax.ErrEmptyVirtualColumn
		}
		return v, nil

	default:
		return nil, fmt.Errorf("kallax: invalid column in ReviewEvent: %s", col)
	}
}

// NewRelationshipRecord returns a new record for the relatiobship in the given
// field.
func (r *ReviewEvent) NewRelationshipRecord(field string) (kallax.Record, error) {
	switch field {
	case "ReviewTarget":
		return new(ReviewTarget), nil

	}
	return nil, fmt.Errorf("kallax: model ReviewEvent has no relationship %s", field)
}

// SetRelationship sets the given relationship in the given field.
func (r *ReviewEvent) SetRelationship(field string, rel interface{}) error {
	switch field {
	case "ReviewTarget":
		val, ok := rel.(*ReviewTarget)
		if !ok {
			return fmt.Errorf("kallax: record of type %t can't be assigned to relationship ReviewTarget", rel)
		}
		if !val.GetID().IsEmpty() {
			r.ReviewTarget = val
		}

		return nil

	}
	return fmt.Errorf("kallax: model ReviewEvent has no relationship %s", field)
}

// ReviewEventStore is the entity to access the records of the type ReviewEvent
// in the database.
type ReviewEventStore struct {
	*kallax.Store
}

// NewReviewEventStore creates a new instance of ReviewEventStore
// using a SQL database.
func NewReviewEventStore(db *sql.DB) *ReviewEventStore {
	return &ReviewEventStore{kallax.NewStore(db)}
}

// GenericStore returns the generic store of this store.
func (s *ReviewEventStore) GenericStore() *kallax.Store {
	return s.Store
}

// SetGenericStore changes the generic store of this store.
func (s *ReviewEventStore) SetGenericStore(store *kallax.Store) {
	s.Store = store
}

// Debug returns a new store that will print all SQL statements to stdout using
// the log.Printf function.
func (s *ReviewEventStore) Debug() *ReviewEventStore {
	return &ReviewEventStore{s.Store.Debug()}
}

// DebugWith returns a new store that will print all SQL statements using the
// given logger function.
func (s *ReviewEventStore) DebugWith(logger kallax.LoggerFunc) *ReviewEventStore {
	return &ReviewEventStore{s.Store.DebugWith(logger)}
}

// DisableCacher turns off prepared statements, which can be useful in some scenarios.
func (s *ReviewEventStore) DisableCacher() *ReviewEventStore {
	return &ReviewEventStore{s.Store.DisableCacher()}
}

func (s *ReviewEventStore) inverseRecords(record *ReviewEvent) []modelSaveFunc {
	var result []modelSaveFunc

	if record.ReviewTarget != nil && !record.ReviewTarget.IsSaving() {
		record.AddVirtualColumn("review_target_id", record.ReviewTarget.GetID())
		result = append(result, func(store *kallax.Store) error {
			_, err := (&ReviewTargetStore{store}).Save(record.ReviewTarget)
			return err
		})
	}

	return result
}

// Insert inserts a ReviewEvent in the database. A non-persisted object is
// required for this operation.
func (s *ReviewEventStore) Insert(record *ReviewEvent) error {
	record.SetSaving(true)
	defer record.SetSaving(false)

	record.CreatedAt = record.CreatedAt.Truncate(time.Microsecond)
	record.UpdatedAt = record.UpdatedAt.Truncate(time.Microsecond)

	inverseRecords := s.inverseRecords(record)

	if len(inverseRecords) > 0 {
		return s.Store.Transaction(func(s *kallax.Store) error {
			for _, r := range inverseRecords {
				if err := r(s); err != nil {
					return err
				}
			}

			if err := s.Insert(Schema.ReviewEvent.BaseSchema, record); err != nil {
				return err
			}

			return nil
		})
	}

	return s.Store.Insert(Schema.ReviewEvent.BaseSchema, record)
}

// Update updates the given record on the database. If the columns are given,
// only these columns will be updated. Otherwise all of them will be.
// Be very careful with this, as you will have a potentially different object
// in memory but not on the database.
// Only writable records can be updated. Writable objects are those that have
// been just inserted or retrieved using a query with no custom select fields.
func (s *ReviewEventStore) Update(record *ReviewEvent, cols ...kallax.SchemaField) (updated int64, err error) {
	record.CreatedAt = record.CreatedAt.Truncate(time.Microsecond)
	record.UpdatedAt = record.UpdatedAt.Truncate(time.Microsecond)

	record.SetSaving(true)
	defer record.SetSaving(false)

	inverseRecords := s.inverseRecords(record)

	if len(inverseRecords) > 0 {
		err = s.Store.Transaction(func(s *kallax.Store) error {
			for _, r := range inverseRecords {
				if err := r(s); err != nil {
					return err
				}
			}

			updated, err = s.Update(Schema.ReviewEvent.BaseSchema, record, cols...)
			if err != nil {
				return err
			}

			return nil
		})
		if err != nil {
			return 0, err
		}

		return updated, nil
	}

	return s.Store.Update(Schema.ReviewEvent.BaseSchema, record, cols...)
}

// Save inserts the object if the record is not persisted, otherwise it updates
// it. Same rules of Update and Insert apply depending on the case.
func (s *ReviewEventStore) Save(record *ReviewEvent) (updated bool, err error) {
	if !record.IsPersisted() {
		return false, s.Insert(record)
	}

	rowsUpdated, err := s.Update(record)
	if err != nil {
		return false, err
	}

	return rowsUpdated > 0, nil
}

// Delete removes the given record from the database.
func (s *ReviewEventStore) Delete(record *ReviewEvent) error {
	return s.Store.Delete(Schema.ReviewEvent.BaseSchema, record)
}

// Find returns the set of results for the given query.
func (s *ReviewEventStore) Find(q *ReviewEventQuery) (*ReviewEventResultSet, error) {
	rs, err := s.Store.Find(q)
	if err != nil {
		return nil, err
	}

	return NewReviewEventResultSet(rs), nil
}

// MustFind returns the set of results for the given query, but panics if there
// is any error.
func (s *ReviewEventStore) MustFind(q *ReviewEventQuery) *ReviewEventResultSet {
	return NewReviewEventResultSet(s.Store.MustFind(q))
}

// Count returns the number of rows that would be retrieved with the given
// query.
func (s *ReviewEventStore) Count(q *ReviewEventQuery) (int64, error) {
	return s.Store.Count(q)
}

// MustCount returns the number of rows that would be retrieved with the given
// query, but panics if there is an error.
func (s *ReviewEventStore) MustCount(q *ReviewEventQuery) int64 {
	return s.Store.MustCount(q)
}

// FindOne returns the first row returned by the given query.
// `ErrNotFound` is returned if there are no results.
func (s *ReviewEventStore) FindOne(q *ReviewEventQuery) (*ReviewEvent, error) {
	q.Limit(1)
	q.Offset(0)
	rs, err := s.Find(q)
	if err != nil {
		return nil, err
	}

	if !rs.Next() {
		return nil, kallax.ErrNotFound
	}

	record, err := rs.Get()
	if err != nil {
		return nil, err
	}

	if err := rs.Close(); err != nil {
		return nil, err
	}

	return record, nil
}

// FindAll returns a list of all the rows returned by the given query.
func (s *ReviewEventStore) FindAll(q *ReviewEventQuery) ([]*ReviewEvent, error) {
	rs, err := s.Find(q)
	if err != nil {
		return nil, err
	}

	return rs.All()
}

// MustFindOne returns the first row retrieved by the given query. It panics
// if there is an error or if there are no rows.
func (s *ReviewEventStore) MustFindOne(q *ReviewEventQuery) *ReviewEvent {
	record, err := s.FindOne(q)
	if err != nil {
		panic(err)
	}
	return record
}

// Reload refreshes the ReviewEvent with the data in the database and
// makes it writable.
func (s *ReviewEventStore) Reload(record *ReviewEvent) error {
	return s.Store.Reload(Schema.ReviewEvent.BaseSchema, record)
}

// Transaction executes the given callback in a transaction and rollbacks if
// an error is returned.
// The transaction is only open in the store passed as a parameter to the
// callback.
func (s *ReviewEventStore) Transaction(callback func(*ReviewEventStore) error) error {
	if callback == nil {
		return kallax.ErrInvalidTxCallback
	}

	return s.Store.Transaction(func(store *kallax.Store) error {
		return callback(&ReviewEventStore{store})
	})
}

// ReviewEventQuery is the object used to create queries for the ReviewEvent
// entity.
type ReviewEventQuery struct {
	*kallax.BaseQuery
}

// NewReviewEventQuery returns a new instance of ReviewEventQuery.
func NewReviewEventQuery() *ReviewEventQuery {
	return &ReviewEventQuery{
		BaseQuery: kallax.NewBaseQuery(Schema.ReviewEvent.BaseSchema),
	}
}

// Select adds columns to select in the query.
func (q *ReviewEventQuery) Select(columns ...kallax.SchemaField) *ReviewEventQuery {
	if len(columns) == 0 {
		return q
	}
	q.BaseQuery.Select(columns...)
	return q
}

// SelectNot excludes columns from being selected in the query.
func (q *ReviewEventQuery) SelectNot(columns ...kallax.SchemaField) *ReviewEventQuery {
	q.BaseQuery.SelectNot(columns...)
	return q
}

// Copy returns a new identical copy of the query. Remember queries are mutable
// so make a copy any time you need to reuse them.
func (q *ReviewEventQuery) Copy() *ReviewEventQuery {
	return &ReviewEventQuery{
		BaseQuery: q.BaseQuery.Copy(),
	}
}

// Order adds order clauses to the query for the given columns.
func (q *ReviewEventQuery) Order(cols ...kallax.ColumnOrder) *ReviewEventQuery {
	q.BaseQuery.Order(cols...)
	return q
}

// BatchSize sets the number of items to fetch per batch when there are 1:N
// relationships selected in the query.
func (q *ReviewEventQuery) BatchSize(size uint64) *ReviewEventQuery {
	q.BaseQuery.BatchSize(size)
	return q
}

// Limit sets the max number of items to retrieve.
func (q *ReviewEventQuery) Limit(n uint64) *ReviewEventQuery {
	q.BaseQuery.Limit(n)
	return q
}

// Offset sets the number of items to skip from the result set of items.
func (q *ReviewEventQuery) Offset(n uint64) *ReviewEventQuery {
	q.BaseQuery.Offset(n)
	return q
}

// Where adds a condition to the query. All conditions added are concatenated
// using a logical AND.
func (q *ReviewEventQuery) Where(cond kallax.Condition) *ReviewEventQuery {
	q.BaseQuery.Where(cond)
	return q
}

func (q *ReviewEventQuery) WithReviewTarget() *ReviewEventQuery {
	q.AddRelation(Schema.ReviewTarget.BaseSchema, "ReviewTarget", kallax.OneToOne, nil)
	return q
}

// FindByID adds a new filter to the query that will require that
// the ID property is equal to one of the passed values; if no passed values,
// it will do nothing.
func (q *ReviewEventQuery) FindByID(v ...kallax.ULID) *ReviewEventQuery {
	if len(v) == 0 {
		return q
	}
	values := make([]interface{}, len(v))
	for i, val := range v {
		values[i] = val
	}
	return q.Where(kallax.In(Schema.ReviewEvent.ID, values...))
}

// FindByStatus adds a new filter to the query that will require that
// the Status property is equal to the passed value.
func (q *ReviewEventQuery) FindByStatus(v EventStatus) *ReviewEventQuery {
	return q.Where(kallax.Eq(Schema.ReviewEvent.Status, v))
}

// FindByInternalID adds a new filter to the query that will require that
// the InternalID property is equal to the passed value.
func (q *ReviewEventQuery) FindByInternalID(v string) *ReviewEventQuery {
	return q.Where(kallax.Eq(Schema.ReviewEvent.InternalID, v))
}

// FindByIsMergeable adds a new filter to the query that will require that
// the IsMergeable property is equal to the passed value.
func (q *ReviewEventQuery) FindByIsMergeable(v bool) *ReviewEventQuery {
	return q.Where(kallax.Eq(Schema.ReviewEvent.IsMergeable, v))
}

// FindByCreatedAt adds a new filter to the query that will require that
// the CreatedAt property is equal to the passed value.
func (q *ReviewEventQuery) FindByCreatedAt(cond kallax.ScalarCond, v time.Time) *ReviewEventQuery {
	return q.Where(cond(Schema.ReviewEvent.CreatedAt, v))
}

// FindByUpdatedAt adds a new filter to the query that will require that
// the UpdatedAt property is equal to the passed value.
func (q *ReviewEventQuery) FindByUpdatedAt(cond kallax.ScalarCond, v time.Time) *ReviewEventQuery {
	return q.Where(cond(Schema.ReviewEvent.UpdatedAt, v))
}

// FindByReviewTarget adds a new filter to the query that will require that
// the foreign key of ReviewTarget is equal to the passed value.
func (q *ReviewEventQuery) FindByReviewTarget(v kallax.ULID) *ReviewEventQuery {
	return q.Where(kallax.Eq(Schema.ReviewEvent.ReviewTargetFK, v))
}

// ReviewEventResultSet is the set of results returned by a query to the
// database.
type ReviewEventResultSet struct {
	ResultSet kallax.ResultSet
	last      *ReviewEvent
	lastErr   error
}

// NewReviewEventResultSet creates a new result set for rows of the type
// ReviewEvent.
func NewReviewEventResultSet(rs kallax.ResultSet) *ReviewEventResultSet {
	return &ReviewEventResultSet{ResultSet: rs}
}

// Next fetches the next item in the result set and returns true if there is
// a next item.
// The result set is closed automatically when there are no more items.
func (rs *ReviewEventResultSet) Next() bool {
	if !rs.ResultSet.Next() {
		rs.lastErr = rs.ResultSet.Close()
		rs.last = nil
		return false
	}

	var record kallax.Record
	record, rs.lastErr = rs.ResultSet.Get(Schema.ReviewEvent.BaseSchema)
	if rs.lastErr != nil {
		rs.last = nil
	} else {
		var ok bool
		rs.last, ok = record.(*ReviewEvent)
		if !ok {
			rs.lastErr = fmt.Errorf("kallax: unable to convert record to *ReviewEvent")
			rs.last = nil
		}
	}

	return true
}

// Get retrieves the last fetched item from the result set and the last error.
func (rs *ReviewEventResultSet) Get() (*ReviewEvent, error) {
	return rs.last, rs.lastErr
}

// ForEach iterates over the complete result set passing every record found to
// the given callback. It is possible to stop the iteration by returning
// `kallax.ErrStop` in the callback.
// Result set is always closed at the end.
func (rs *ReviewEventResultSet) ForEach(fn func(*ReviewEvent) error) error {
	for rs.Next() {
		record, err := rs.Get()
		if err != nil {
			return err
		}

		if err := fn(record); err != nil {
			if err == kallax.ErrStop {
				return rs.Close()
			}

			return err
		}
	}
	return nil
}

// All returns all records on the result set and closes the result set.
func (rs *ReviewEventResultSet) All() ([]*ReviewEvent, error) {
	var result []*ReviewEvent
	for rs.Next() {
		record, err := rs.Get()
		if err != nil {
			return nil, err
		}
		result = append(result, record)
	}
	return result, nil
}

// One returns the first record on the result set and closes the result set.
func (rs *ReviewEventResultSet) One() (*ReviewEvent, error) {
	if !rs.Next() {
		return nil, kallax.ErrNotFound
	}

	record, err := rs.Get()
	if err != nil {
		return nil, err
	}

	if err := rs.Close(); err != nil {
		return nil, err
	}

	return record, nil
}

// Err returns the last error occurred.
func (rs *ReviewEventResultSet) Err() error {
	return rs.lastErr
}

// Close closes the result set.
func (rs *ReviewEventResultSet) Close() error {
	return rs.ResultSet.Close()
}

// NewReviewTarget returns a new instance of ReviewTarget.
func NewReviewTarget(e *pb.ReviewEvent) (record *ReviewTarget) {
	return newReviewTarget(e)
}

// GetID returns the primary key of the model.
func (r *ReviewTarget) GetID() kallax.Identifier {
	return (*kallax.ULID)(&r.ID)
}

// ColumnAddress returns the pointer to the value of the given column.
func (r *ReviewTarget) ColumnAddress(col string) (interface{}, error) {
	switch col {
	case "id":
		return (*kallax.ULID)(&r.ID), nil
	case "created_at":
		return &r.Timestamps.CreatedAt, nil
	case "updated_at":
		return &r.Timestamps.UpdatedAt, nil
	case "provider":
		return &r.Provider, nil
	case "internal_id":
		return &r.InternalID, nil
	case "repository_id":
		return &r.RepositoryID, nil
	case "number":
		return &r.Number, nil

	default:
		return nil, fmt.Errorf("kallax: invalid column in ReviewTarget: %s", col)
	}
}

// Value returns the value of the given column.
func (r *ReviewTarget) Value(col string) (interface{}, error) {
	switch col {
	case "id":
		return r.ID, nil
	case "created_at":
		return r.Timestamps.CreatedAt, nil
	case "updated_at":
		return r.Timestamps.UpdatedAt, nil
	case "provider":
		return r.Provider, nil
	case "internal_id":
		return r.InternalID, nil
	case "repository_id":
		return r.RepositoryID, nil
	case "number":
		return r.Number, nil

	default:
		return nil, fmt.Errorf("kallax: invalid column in ReviewTarget: %s", col)
	}
}

// NewRelationshipRecord returns a new record for the relatiobship in the given
// field.
func (r *ReviewTarget) NewRelationshipRecord(field string) (kallax.Record, error) {
	return nil, fmt.Errorf("kallax: model ReviewTarget has no relationships")
}

// SetRelationship sets the given relationship in the given field.
func (r *ReviewTarget) SetRelationship(field string, rel interface{}) error {
	return fmt.Errorf("kallax: model ReviewTarget has no relationships")
}

// ReviewTargetStore is the entity to access the records of the type ReviewTarget
// in the database.
type ReviewTargetStore struct {
	*kallax.Store
}

// NewReviewTargetStore creates a new instance of ReviewTargetStore
// using a SQL database.
func NewReviewTargetStore(db *sql.DB) *ReviewTargetStore {
	return &ReviewTargetStore{kallax.NewStore(db)}
}

// GenericStore returns the generic store of this store.
func (s *ReviewTargetStore) GenericStore() *kallax.Store {
	return s.Store
}

// SetGenericStore changes the generic store of this store.
func (s *ReviewTargetStore) SetGenericStore(store *kallax.Store) {
	s.Store = store
}

// Debug returns a new store that will print all SQL statements to stdout using
// the log.Printf function.
func (s *ReviewTargetStore) Debug() *ReviewTargetStore {
	return &ReviewTargetStore{s.Store.Debug()}
}

// DebugWith returns a new store that will print all SQL statements using the
// given logger function.
func (s *ReviewTargetStore) DebugWith(logger kallax.LoggerFunc) *ReviewTargetStore {
	return &ReviewTargetStore{s.Store.DebugWith(logger)}
}

// DisableCacher turns off prepared statements, which can be useful in some scenarios.
func (s *ReviewTargetStore) DisableCacher() *ReviewTargetStore {
	return &ReviewTargetStore{s.Store.DisableCacher()}
}

// Insert inserts a ReviewTarget in the database. A non-persisted object is
// required for this operation.
func (s *ReviewTargetStore) Insert(record *ReviewTarget) error {
	record.SetSaving(true)
	defer record.SetSaving(false)

	record.CreatedAt = record.CreatedAt.Truncate(time.Microsecond)
	record.UpdatedAt = record.UpdatedAt.Truncate(time.Microsecond)

	if err := record.BeforeSave(); err != nil {
		return err
	}

	return s.Store.Insert(Schema.ReviewTarget.BaseSchema, record)
}

// Update updates the given record on the database. If the columns are given,
// only these columns will be updated. Otherwise all of them will be.
// Be very careful with this, as you will have a potentially different object
// in memory but not on the database.
// Only writable records can be updated. Writable objects are those that have
// been just inserted or retrieved using a query with no custom select fields.
func (s *ReviewTargetStore) Update(record *ReviewTarget, cols ...kallax.SchemaField) (updated int64, err error) {
	record.CreatedAt = record.CreatedAt.Truncate(time.Microsecond)
	record.UpdatedAt = record.UpdatedAt.Truncate(time.Microsecond)

	record.SetSaving(true)
	defer record.SetSaving(false)

	if err := record.BeforeSave(); err != nil {
		return 0, err
	}

	return s.Store.Update(Schema.ReviewTarget.BaseSchema, record, cols...)
}

// Save inserts the object if the record is not persisted, otherwise it updates
// it. Same rules of Update and Insert apply depending on the case.
func (s *ReviewTargetStore) Save(record *ReviewTarget) (updated bool, err error) {
	if !record.IsPersisted() {
		return false, s.Insert(record)
	}

	rowsUpdated, err := s.Update(record)
	if err != nil {
		return false, err
	}

	return rowsUpdated > 0, nil
}

// Delete removes the given record from the database.
func (s *ReviewTargetStore) Delete(record *ReviewTarget) error {
	return s.Store.Delete(Schema.ReviewTarget.BaseSchema, record)
}

// Find returns the set of results for the given query.
func (s *ReviewTargetStore) Find(q *ReviewTargetQuery) (*ReviewTargetResultSet, error) {
	rs, err := s.Store.Find(q)
	if err != nil {
		return nil, err
	}

	return NewReviewTargetResultSet(rs), nil
}

// MustFind returns the set of results for the given query, but panics if there
// is any error.
func (s *ReviewTargetStore) MustFind(q *ReviewTargetQuery) *ReviewTargetResultSet {
	return NewReviewTargetResultSet(s.Store.MustFind(q))
}

// Count returns the number of rows that would be retrieved with the given
// query.
func (s *ReviewTargetStore) Count(q *ReviewTargetQuery) (int64, error) {
	return s.Store.Count(q)
}

// MustCount returns the number of rows that would be retrieved with the given
// query, but panics if there is an error.
func (s *ReviewTargetStore) MustCount(q *ReviewTargetQuery) int64 {
	return s.Store.MustCount(q)
}

// FindOne returns the first row returned by the given query.
// `ErrNotFound` is returned if there are no results.
func (s *ReviewTargetStore) FindOne(q *ReviewTargetQuery) (*ReviewTarget, error) {
	q.Limit(1)
	q.Offset(0)
	rs, err := s.Find(q)
	if err != nil {
		return nil, err
	}

	if !rs.Next() {
		return nil, kallax.ErrNotFound
	}

	record, err := rs.Get()
	if err != nil {
		return nil, err
	}

	if err := rs.Close(); err != nil {
		return nil, err
	}

	return record, nil
}

// FindAll returns a list of all the rows returned by the given query.
func (s *ReviewTargetStore) FindAll(q *ReviewTargetQuery) ([]*ReviewTarget, error) {
	rs, err := s.Find(q)
	if err != nil {
		return nil, err
	}

	return rs.All()
}

// MustFindOne returns the first row retrieved by the given query. It panics
// if there is an error or if there are no rows.
func (s *ReviewTargetStore) MustFindOne(q *ReviewTargetQuery) *ReviewTarget {
	record, err := s.FindOne(q)
	if err != nil {
		panic(err)
	}
	return record
}

// Reload refreshes the ReviewTarget with the data in the database and
// makes it writable.
func (s *ReviewTargetStore) Reload(record *ReviewTarget) error {
	return s.Store.Reload(Schema.ReviewTarget.BaseSchema, record)
}

// Transaction executes the given callback in a transaction and rollbacks if
// an error is returned.
// The transaction is only open in the store passed as a parameter to the
// callback.
func (s *ReviewTargetStore) Transaction(callback func(*ReviewTargetStore) error) error {
	if callback == nil {
		return kallax.ErrInvalidTxCallback
	}

	return s.Store.Transaction(func(store *kallax.Store) error {
		return callback(&ReviewTargetStore{store})
	})
}

// ReviewTargetQuery is the object used to create queries for the ReviewTarget
// entity.
type ReviewTargetQuery struct {
	*kallax.BaseQuery
}

// NewReviewTargetQuery returns a new instance of ReviewTargetQuery.
func NewReviewTargetQuery() *ReviewTargetQuery {
	return &ReviewTargetQuery{
		BaseQuery: kallax.NewBaseQuery(Schema.ReviewTarget.BaseSchema),
	}
}

// Select adds columns to select in the query.
func (q *ReviewTargetQuery) Select(columns ...kallax.SchemaField) *ReviewTargetQuery {
	if len(columns) == 0 {
		return q
	}
	q.BaseQuery.Select(columns...)
	return q
}

// SelectNot excludes columns from being selected in the query.
func (q *ReviewTargetQuery) SelectNot(columns ...kallax.SchemaField) *ReviewTargetQuery {
	q.BaseQuery.SelectNot(columns...)
	return q
}

// Copy returns a new identical copy of the query. Remember queries are mutable
// so make a copy any time you need to reuse them.
func (q *ReviewTargetQuery) Copy() *ReviewTargetQuery {
	return &ReviewTargetQuery{
		BaseQuery: q.BaseQuery.Copy(),
	}
}

// Order adds order clauses to the query for the given columns.
func (q *ReviewTargetQuery) Order(cols ...kallax.ColumnOrder) *ReviewTargetQuery {
	q.BaseQuery.Order(cols...)
	return q
}

// BatchSize sets the number of items to fetch per batch when there are 1:N
// relationships selected in the query.
func (q *ReviewTargetQuery) BatchSize(size uint64) *ReviewTargetQuery {
	q.BaseQuery.BatchSize(size)
	return q
}

// Limit sets the max number of items to retrieve.
func (q *ReviewTargetQuery) Limit(n uint64) *ReviewTargetQuery {
	q.BaseQuery.Limit(n)
	return q
}

// Offset sets the number of items to skip from the result set of items.
func (q *ReviewTargetQuery) Offset(n uint64) *ReviewTargetQuery {
	q.BaseQuery.Offset(n)
	return q
}

// Where adds a condition to the query. All conditions added are concatenated
// using a logical AND.
func (q *ReviewTargetQuery) Where(cond kallax.Condition) *ReviewTargetQuery {
	q.BaseQuery.Where(cond)
	return q
}

// FindByID adds a new filter to the query that will require that
// the ID property is equal to one of the passed values; if no passed values,
// it will do nothing.
func (q *ReviewTargetQuery) FindByID(v ...kallax.ULID) *ReviewTargetQuery {
	if len(v) == 0 {
		return q
	}
	values := make([]interface{}, len(v))
	for i, val := range v {
		values[i] = val
	}
	return q.Where(kallax.In(Schema.ReviewTarget.ID, values...))
}

// FindByCreatedAt adds a new filter to the query that will require that
// the CreatedAt property is equal to the passed value.
func (q *ReviewTargetQuery) FindByCreatedAt(cond kallax.ScalarCond, v time.Time) *ReviewTargetQuery {
	return q.Where(cond(Schema.ReviewTarget.CreatedAt, v))
}

// FindByUpdatedAt adds a new filter to the query that will require that
// the UpdatedAt property is equal to the passed value.
func (q *ReviewTargetQuery) FindByUpdatedAt(cond kallax.ScalarCond, v time.Time) *ReviewTargetQuery {
	return q.Where(cond(Schema.ReviewTarget.UpdatedAt, v))
}

// FindByProvider adds a new filter to the query that will require that
// the Provider property is equal to the passed value.
func (q *ReviewTargetQuery) FindByProvider(v string) *ReviewTargetQuery {
	return q.Where(kallax.Eq(Schema.ReviewTarget.Provider, v))
}

// FindByInternalID adds a new filter to the query that will require that
// the InternalID property is equal to the passed value.
func (q *ReviewTargetQuery) FindByInternalID(v string) *ReviewTargetQuery {
	return q.Where(kallax.Eq(Schema.ReviewTarget.InternalID, v))
}

// FindByRepositoryID adds a new filter to the query that will require that
// the RepositoryID property is equal to the passed value.
func (q *ReviewTargetQuery) FindByRepositoryID(cond kallax.ScalarCond, v uint32) *ReviewTargetQuery {
	return q.Where(cond(Schema.ReviewTarget.RepositoryID, v))
}

// FindByNumber adds a new filter to the query that will require that
// the Number property is equal to the passed value.
func (q *ReviewTargetQuery) FindByNumber(cond kallax.ScalarCond, v uint32) *ReviewTargetQuery {
	return q.Where(cond(Schema.ReviewTarget.Number, v))
}

// ReviewTargetResultSet is the set of results returned by a query to the
// database.
type ReviewTargetResultSet struct {
	ResultSet kallax.ResultSet
	last      *ReviewTarget
	lastErr   error
}

// NewReviewTargetResultSet creates a new result set for rows of the type
// ReviewTarget.
func NewReviewTargetResultSet(rs kallax.ResultSet) *ReviewTargetResultSet {
	return &ReviewTargetResultSet{ResultSet: rs}
}

// Next fetches the next item in the result set and returns true if there is
// a next item.
// The result set is closed automatically when there are no more items.
func (rs *ReviewTargetResultSet) Next() bool {
	if !rs.ResultSet.Next() {
		rs.lastErr = rs.ResultSet.Close()
		rs.last = nil
		return false
	}

	var record kallax.Record
	record, rs.lastErr = rs.ResultSet.Get(Schema.ReviewTarget.BaseSchema)
	if rs.lastErr != nil {
		rs.last = nil
	} else {
		var ok bool
		rs.last, ok = record.(*ReviewTarget)
		if !ok {
			rs.lastErr = fmt.Errorf("kallax: unable to convert record to *ReviewTarget")
			rs.last = nil
		}
	}

	return true
}

// Get retrieves the last fetched item from the result set and the last error.
func (rs *ReviewTargetResultSet) Get() (*ReviewTarget, error) {
	return rs.last, rs.lastErr
}

// ForEach iterates over the complete result set passing every record found to
// the given callback. It is possible to stop the iteration by returning
// `kallax.ErrStop` in the callback.
// Result set is always closed at the end.
func (rs *ReviewTargetResultSet) ForEach(fn func(*ReviewTarget) error) error {
	for rs.Next() {
		record, err := rs.Get()
		if err != nil {
			return err
		}

		if err := fn(record); err != nil {
			if err == kallax.ErrStop {
				return rs.Close()
			}

			return err
		}
	}
	return nil
}

// All returns all records on the result set and closes the result set.
func (rs *ReviewTargetResultSet) All() ([]*ReviewTarget, error) {
	var result []*ReviewTarget
	for rs.Next() {
		record, err := rs.Get()
		if err != nil {
			return nil, err
		}
		result = append(result, record)
	}
	return result, nil
}

// One returns the first record on the result set and closes the result set.
func (rs *ReviewTargetResultSet) One() (*ReviewTarget, error) {
	if !rs.Next() {
		return nil, kallax.ErrNotFound
	}

	record, err := rs.Get()
	if err != nil {
		return nil, err
	}

	if err := rs.Close(); err != nil {
		return nil, err
	}

	return record, nil
}

// Err returns the last error occurred.
func (rs *ReviewTargetResultSet) Err() error {
	return rs.lastErr
}

// Close closes the result set.
func (rs *ReviewTargetResultSet) Close() error {
	return rs.ResultSet.Close()
}

type schema struct {
	Comment      *schemaComment
	Organization *schemaOrganization
	PushEvent    *schemaPushEvent
	ReviewEvent  *schemaReviewEvent
	ReviewTarget *schemaReviewTarget
}

type schemaComment struct {
	*kallax.BaseSchema
	ID            kallax.SchemaField
	CreatedAt     kallax.SchemaField
	UpdatedAt     kallax.SchemaField
	ReviewEventFK kallax.SchemaField
	File          kallax.SchemaField
	Line          kallax.SchemaField
	Text          kallax.SchemaField
	Confidence    kallax.SchemaField
	Analyzer      kallax.SchemaField
}

type schemaOrganization struct {
	*kallax.BaseSchema
	ID         kallax.SchemaField
	Provider   kallax.SchemaField
	InternalID kallax.SchemaField
	Config     kallax.SchemaField
}

type schemaPushEvent struct {
	*kallax.BaseSchema
	ID              kallax.SchemaField
	Status          kallax.SchemaField
	Provider        kallax.SchemaField
	InternalID      kallax.SchemaField
	CreatedAt       kallax.SchemaField
	Commits         kallax.SchemaField
	DistinctCommits kallax.SchemaField
	Configuration   *schemaPushEventConfiguration
	Base            *schemaPushEventBase
	Head            *schemaPushEventHead
}

type schemaReviewEvent struct {
	*kallax.BaseSchema
	ID             kallax.SchemaField
	Status         kallax.SchemaField
	InternalID     kallax.SchemaField
	IsMergeable    kallax.SchemaField
	Source         *schemaReviewEventSource
	Merge          *schemaReviewEventMerge
	Configuration  *schemaReviewEventConfiguration
	Base           *schemaReviewEventBase
	Head           *schemaReviewEventHead
	CreatedAt      kallax.SchemaField
	UpdatedAt      kallax.SchemaField
	ReviewTargetFK kallax.SchemaField
}

type schemaReviewTarget struct {
	*kallax.BaseSchema
	ID           kallax.SchemaField
	CreatedAt    kallax.SchemaField
	UpdatedAt    kallax.SchemaField
	Provider     kallax.SchemaField
	InternalID   kallax.SchemaField
	RepositoryID kallax.SchemaField
	Number       kallax.SchemaField
}

type schemaPushEventBase struct {
	*kallax.BaseSchemaField
	InternalRepositoryURL kallax.SchemaField
	ReferenceName         kallax.SchemaField
	Hash                  kallax.SchemaField
}

type schemaPushEventConfiguration struct {
	*kallax.BaseSchemaField
	Fields               kallax.SchemaField
	XXX_NoUnkeyedLiteral kallax.SchemaField
	XXX_unrecognized     kallax.SchemaField
	XXX_sizecache        kallax.SchemaField
}

type schemaPushEventHead struct {
	*kallax.BaseSchemaField
	InternalRepositoryURL kallax.SchemaField
	ReferenceName         kallax.SchemaField
	Hash                  kallax.SchemaField
}

type schemaReviewEventBase struct {
	*kallax.BaseSchemaField
	InternalRepositoryURL kallax.SchemaField
	ReferenceName         kallax.SchemaField
	Hash                  kallax.SchemaField
}

type schemaReviewEventConfiguration struct {
	*kallax.BaseSchemaField
	Fields               kallax.SchemaField
	XXX_NoUnkeyedLiteral kallax.SchemaField
	XXX_unrecognized     kallax.SchemaField
	XXX_sizecache        kallax.SchemaField
}

type schemaReviewEventHead struct {
	*kallax.BaseSchemaField
	InternalRepositoryURL kallax.SchemaField
	ReferenceName         kallax.SchemaField
	Hash                  kallax.SchemaField
}

type schemaReviewEventMerge struct {
	*kallax.BaseSchemaField
	InternalRepositoryURL kallax.SchemaField
	ReferenceName         kallax.SchemaField
	Hash                  kallax.SchemaField
}

type schemaReviewEventSource struct {
	*kallax.BaseSchemaField
	InternalRepositoryURL kallax.SchemaField
	ReferenceName         kallax.SchemaField
	Hash                  kallax.SchemaField
}

var Schema = &schema{
	Comment: &schemaComment{
		BaseSchema: kallax.NewBaseSchema(
			"comment",
			"__comment",
			kallax.NewSchemaField("id"),
			kallax.ForeignKeys{
				"ReviewEvent": kallax.NewForeignKey("review_event_id", true),
			},
			func() kallax.Record {
				return new(Comment)
			},
			false,
			kallax.NewSchemaField("id"),
			kallax.NewSchemaField("created_at"),
			kallax.NewSchemaField("updated_at"),
			kallax.NewSchemaField("review_event_id"),
			kallax.NewSchemaField("file"),
			kallax.NewSchemaField("line"),
			kallax.NewSchemaField("text"),
			kallax.NewSchemaField("confidence"),
			kallax.NewSchemaField("analyzer"),
		),
		ID:            kallax.NewSchemaField("id"),
		CreatedAt:     kallax.NewSchemaField("created_at"),
		UpdatedAt:     kallax.NewSchemaField("updated_at"),
		ReviewEventFK: kallax.NewSchemaField("review_event_id"),
		File:          kallax.NewSchemaField("file"),
		Line:          kallax.NewSchemaField("line"),
		Text:          kallax.NewSchemaField("text"),
		Confidence:    kallax.NewSchemaField("confidence"),
		Analyzer:      kallax.NewSchemaField("analyzer"),
	},
	Organization: &schemaOrganization{
		BaseSchema: kallax.NewBaseSchema(
			"organization",
			"__organization",
			kallax.NewSchemaField("id"),
			kallax.ForeignKeys{},
			func() kallax.Record {
				return new(Organization)
			},
			false,
			kallax.NewSchemaField("id"),
			kallax.NewSchemaField("provider"),
			kallax.NewSchemaField("internal_id"),
			kallax.NewSchemaField("config"),
		),
		ID:         kallax.NewSchemaField("id"),
		Provider:   kallax.NewSchemaField("provider"),
		InternalID: kallax.NewSchemaField("internal_id"),
		Config:     kallax.NewSchemaField("config"),
	},
	PushEvent: &schemaPushEvent{
		BaseSchema: kallax.NewBaseSchema(
			"push_event",
			"__pushevent",
			kallax.NewSchemaField("id"),
			kallax.ForeignKeys{},
			func() kallax.Record {
				return new(PushEvent)
			},
			false,
			kallax.NewSchemaField("id"),
			kallax.NewSchemaField("status"),
			kallax.NewSchemaField("provider"),
			kallax.NewSchemaField("internal_id"),
			kallax.NewSchemaField("created_at"),
			kallax.NewSchemaField("commits"),
			kallax.NewSchemaField("distinct_commits"),
			kallax.NewSchemaField("configuration"),
			kallax.NewSchemaField("base"),
			kallax.NewSchemaField("head"),
		),
		ID:              kallax.NewSchemaField("id"),
		Status:          kallax.NewSchemaField("status"),
		Provider:        kallax.NewSchemaField("provider"),
		InternalID:      kallax.NewSchemaField("internal_id"),
		CreatedAt:       kallax.NewSchemaField("created_at"),
		Commits:         kallax.NewSchemaField("commits"),
		DistinctCommits: kallax.NewSchemaField("distinct_commits"),
		Configuration: &schemaPushEventConfiguration{
			BaseSchemaField:      kallax.NewSchemaField("configuration").(*kallax.BaseSchemaField),
			Fields:               kallax.NewJSONSchemaKey(kallax.JSONAny, "push_event", "configuration", "fields"),
			XXX_NoUnkeyedLiteral: kallax.NewJSONSchemaKey(kallax.JSONAny, "push_event", "configuration", "-"),
			XXX_unrecognized:     kallax.NewJSONSchemaArray("push_event", "configuration", "-"),
			XXX_sizecache:        kallax.NewJSONSchemaKey(kallax.JSONInt, "push_event", "configuration", "-"),
		},
		Base: &schemaPushEventBase{
			BaseSchemaField:       kallax.NewSchemaField("base").(*kallax.BaseSchemaField),
			InternalRepositoryURL: kallax.NewJSONSchemaKey(kallax.JSONText, "push_event", "base", "internal_repository_url"),
			ReferenceName:         kallax.NewJSONSchemaKey(kallax.JSONText, "push_event", "base", "reference_name"),
			Hash:                  kallax.NewJSONSchemaKey(kallax.JSONText, "push_event", "base", "hash"),
		},
		Head: &schemaPushEventHead{
			BaseSchemaField:       kallax.NewSchemaField("head").(*kallax.BaseSchemaField),
			InternalRepositoryURL: kallax.NewJSONSchemaKey(kallax.JSONText, "push_event", "head", "internal_repository_url"),
			ReferenceName:         kallax.NewJSONSchemaKey(kallax.JSONText, "push_event", "head", "reference_name"),
			Hash:                  kallax.NewJSONSchemaKey(kallax.JSONText, "push_event", "head", "hash"),
		},
	},
	ReviewEvent: &schemaReviewEvent{
		BaseSchema: kallax.NewBaseSchema(
			"review_event",
			"__reviewevent",
			kallax.NewSchemaField("id"),
			kallax.ForeignKeys{
				"ReviewTarget": kallax.NewForeignKey("review_target_id", true),
			},
			func() kallax.Record {
				return new(ReviewEvent)
			},
			false,
			kallax.NewSchemaField("id"),
			kallax.NewSchemaField("status"),
			kallax.NewSchemaField("internal_id"),
			kallax.NewSchemaField("is_mergeable"),
			kallax.NewSchemaField("source"),
			kallax.NewSchemaField("merge"),
			kallax.NewSchemaField("configuration"),
			kallax.NewSchemaField("base"),
			kallax.NewSchemaField("head"),
			kallax.NewSchemaField("created_at"),
			kallax.NewSchemaField("updated_at"),
			kallax.NewSchemaField("review_target_id"),
		),
		ID:          kallax.NewSchemaField("id"),
		Status:      kallax.NewSchemaField("status"),
		InternalID:  kallax.NewSchemaField("internal_id"),
		IsMergeable: kallax.NewSchemaField("is_mergeable"),
		Source: &schemaReviewEventSource{
			BaseSchemaField:       kallax.NewSchemaField("source").(*kallax.BaseSchemaField),
			InternalRepositoryURL: kallax.NewJSONSchemaKey(kallax.JSONText, "source", "internal_repository_url"),
			ReferenceName:         kallax.NewJSONSchemaKey(kallax.JSONText, "source", "reference_name"),
			Hash:                  kallax.NewJSONSchemaKey(kallax.JSONText, "source", "hash"),
		},
		Merge: &schemaReviewEventMerge{
			BaseSchemaField:       kallax.NewSchemaField("merge").(*kallax.BaseSchemaField),
			InternalRepositoryURL: kallax.NewJSONSchemaKey(kallax.JSONText, "merge", "internal_repository_url"),
			ReferenceName:         kallax.NewJSONSchemaKey(kallax.JSONText, "merge", "reference_name"),
			Hash:                  kallax.NewJSONSchemaKey(kallax.JSONText, "merge", "hash"),
		},
		Configuration: &schemaReviewEventConfiguration{
			BaseSchemaField:      kallax.NewSchemaField("configuration").(*kallax.BaseSchemaField),
			Fields:               kallax.NewJSONSchemaKey(kallax.JSONAny, "configuration", "fields"),
			XXX_NoUnkeyedLiteral: kallax.NewJSONSchemaKey(kallax.JSONAny, "configuration", "-"),
			XXX_unrecognized:     kallax.NewJSONSchemaArray("configuration", "-"),
			XXX_sizecache:        kallax.NewJSONSchemaKey(kallax.JSONInt, "configuration", "-"),
		},
		Base: &schemaReviewEventBase{
			BaseSchemaField:       kallax.NewSchemaField("base").(*kallax.BaseSchemaField),
			InternalRepositoryURL: kallax.NewJSONSchemaKey(kallax.JSONText, "base", "internal_repository_url"),
			ReferenceName:         kallax.NewJSONSchemaKey(kallax.JSONText, "base", "reference_name"),
			Hash:                  kallax.NewJSONSchemaKey(kallax.JSONText, "base", "hash"),
		},
		Head: &schemaReviewEventHead{
			BaseSchemaField:       kallax.NewSchemaField("head").(*kallax.BaseSchemaField),
			InternalRepositoryURL: kallax.NewJSONSchemaKey(kallax.JSONText, "head", "internal_repository_url"),
			ReferenceName:         kallax.NewJSONSchemaKey(kallax.JSONText, "head", "reference_name"),
			Hash:                  kallax.NewJSONSchemaKey(kallax.JSONText, "head", "hash"),
		},
		CreatedAt:      kallax.NewSchemaField("created_at"),
		UpdatedAt:      kallax.NewSchemaField("updated_at"),
		ReviewTargetFK: kallax.NewSchemaField("review_target_id"),
	},
	ReviewTarget: &schemaReviewTarget{
		BaseSchema: kallax.NewBaseSchema(
			"review_target",
			"__reviewtarget",
			kallax.NewSchemaField("id"),
			kallax.ForeignKeys{},
			func() kallax.Record {
				return new(ReviewTarget)
			},
			false,
			kallax.NewSchemaField("id"),
			kallax.NewSchemaField("created_at"),
			kallax.NewSchemaField("updated_at"),
			kallax.NewSchemaField("provider"),
			kallax.NewSchemaField("internal_id"),
			kallax.NewSchemaField("repository_id"),
			kallax.NewSchemaField("number"),
		),
		ID:           kallax.NewSchemaField("id"),
		CreatedAt:    kallax.NewSchemaField("created_at"),
		UpdatedAt:    kallax.NewSchemaField("updated_at"),
		Provider:     kallax.NewSchemaField("provider"),
		InternalID:   kallax.NewSchemaField("internal_id"),
		RepositoryID: kallax.NewSchemaField("repository_id"),
		Number:       kallax.NewSchemaField("number"),
	},
}
